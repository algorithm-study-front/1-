
## [150. Evaluate Reverse Polish Notation](https://leetcode.com/problems/evaluate-reverse-polish-notation/)

```js
/**
 * @param {string[]} tokens
 * @return {number}
 */
const evalRPN = function(tokens) {
    const stack = [];

    [...tokens].forEach((token) => {
        switch (token) {
            case '+':
                stack.push(stack.pop() + stack.pop());
                break;
            case '-':
                const _last = stack.pop();
                const _secondLast = stack.pop();
                stack.push(_secondLast - _last);
                break;
            case '*':
                stack.push(stack.pop() * stack.pop());
                break;
            case '/':
                const last = stack.pop();
                const secondLast = stack.pop();
                stack.push(parseInt(secondLast / last));
                break;
            default:
                stack.push(Number(token));
                break;
        }        
    })

    return stack[0];
};
```

![](https://velog.velcdn.com/images/dusdjeks/post/7e97baac-e750-43c6-9042-bd6f7a739c26/image.png)


## [387. First Unique Character in a String](https://leetcode.com/problems/first-unique-character-in-a-string/)

```js
/**
 * @param {string} s
 * @return {number}
 */
const firstUniqChar = function(s) {
    // 아니면 map이랑 visited를 따로 두는거지. 
    // map에 char, index를 두고, 만약 map에 존재하는 값이면 visited로 빼고, map에서 제거. 

    const map = new Map();
    const visited = new Set();

    [...s].forEach((char, index) => {
        if (visited.has(char)) {
            map.delete(char);
        } else {
            map.set(char, index);
            visited.add(char);
        }
    });

    for( [key, value] of map ) {
        return value;
    }

    return -1; 
};
```

![](https://velog.velcdn.com/images/dusdjeks/post/5d190d8c-d86c-484a-830e-159cc22619c3/image.png)


## [1700. Number of Students Unable to Eat Lunch](https://leetcode.com/problems/number-of-students-unable-to-eat-lunch/)


```js
const isIterable = (element, array) => {
    if (array.length === 0) return true;

    for (const item of array) {
        if (item === element) return true;
    }
    return false;
}

/**
 * @param {number[]} students
 * @param {number[]} sandwiches
 * @return {number}
 */
const countStudents = function(students, sandwiches) {
    // stack[0]과 queue[0]이 일치하는지 확인한다. 
    // 일치할 경우 pop과 shift 한다. 
    // 일치하지 않을 경우 queue를 shift하고 push한다. 
    // stack이 비워질때까지 반복한다. 
    // 불가능한 경우에는 어떻게 알지 ? 
    // queue의 크기만큼 반복했는데, 아무런 변화가 없을 때. 이건 이전 단계 구현하고 생각해보자. 
    const queue = [...students];
    const stack = [...sandwiches];


    while (stack.length > 0) {
        if (stack[0] === queue[0]) {
            stack.shift();
            queue.shift();
        } else {
            queue.push(queue.shift());
        }

        if (!isIterable(stack[0], queue)) return stack.length;
    }

    return 0;
};
```
![](https://velog.velcdn.com/images/dusdjeks/post/12bab296-c575-4133-a344-1bffcab2a0cc/image.png)

