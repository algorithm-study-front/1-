## [LeetCode] 94. Binary Tree Inorder Traversal

[문제 확인](https://leetcode.com/problems/binary-tree-inorder-traversal/)

```js
const inorderTraversal = function (root) {
    let output = [];
    inorderDfs(root, output);
    return output;
};

function inorderDfs(tree, output) {
    if (tree === null) {
        return;
    }
    inorderDfs(tree.left, output);
    output.push(tree.val);
    inorderDfs(tree.right, output);
}
```

</br>
</br>

## [LeetCode] 100. Same Tree

[문제 확인](https://leetcode.com/problems/same-tree/)

```js
const isSameTree = (p, q) => {
    if (p === null && q === null) return true;
    if ((p !== null && q === null) || (p === null && q === null)) return false;
    if (p.val !== q.val) return false;
    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
};
```

</br>
</br>

## [LeetCode] 101. Symmetric Tree

[문제 확인](https://leetcode.com/problems/symmetric-tree/)

```js
var isSymmetric = function (root) {
    const leftSubTree = root.left;
    const rightSubTree = root.right;

    return checkIsMirrorTree(leftSubTree, rightSubTree);

    function checkIsMirrorTree(leftSubTree, rightSubTree) {
        if (!leftSubTree && !rightSubTree) {
            return true;
        }

        if (leftSubTree && !rightSubTree) {
            return false;
        }

        if (rightSubTree && !leftSubTree) {
            return false;
        }

        if (leftSubTree.val !== rightSubTree.val) {
            return false;
        }

        if (!checkIsMirrorTree(leftSubTree.left, rightSubTree.right)) {
            return false;
        }

        if (!checkIsMirrorTree(leftSubTree.right, rightSubTree.left)) {
            return false;
        }

        return true;
    }
};
```
