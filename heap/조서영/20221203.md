## [LeetCode] 264. Ugly Number II

[문제 확인](https://leetcode.com/problems/ugly-number-ii/description/)

-   결과: Time Limit Exceeded

```js
let nthUglyNumber = function (n) {
    let ch = Array(1000000).fill(0);
    const doubled_n = ch.length;
    ch[1] = 1;

    for (let i = 1; i < doubled_n; i++) {
        if (ch[i] === 1) {
            let searchIdx = [i * 2, i * 3, i * 5];
            searchIdx.forEach((ele) => {
                if (ele <= doubled_n) ch[ele] = 1;
            });
        }
    }

    let count = 0;
    for (let i = 1; i < ch.length; i++) {
        if (ch[i] === 1) count++;
        if (count === n) return i;
    }
};
```

</br>
</br>

## [LeetCode] 1046. Last Stone Weight

[문제 확인](https://leetcode.com/problems/last-stone-weight/description/)

-   결과: Accepted, Runtime: 52ms(Beats 99.82%), Memory: 43.6MB(Beats 45.37%)

```js
let lastStoneWeight = function (stones) {
    let sorted = stones.slice().sort((a, b) => a - b);

    while (sorted.length > 1) {
        let x = sorted[sorted.length - 2];
        let y = sorted[sorted.length - 1];

        if (x === y) sorted = sorted.slice(0, -2).sort((a, b) => a - b);
        if (x < y) {
            sorted = sorted.slice(0, -2);
            sorted.push(y - x);
            sorted = sorted.sort((a, b) => a - b);
        }
    }

    return sorted.length ? sorted[0] : 0;
};
```

<br>
<br>

## [LeetCode] 1337. The K Weakest Rows in a Matrix

[문제 확인](https://leetcode.com/problems/the-k-weakest-rows-in-a-matrix/description/)

-   결과: Accepted, Runtime: 105ms(Beats 52.9%), Memory: 44.6MB(Beats 30.64%)

```js
let kWeakestRows = function (mat, k) {
    let soldiers = Array(mat.length).fill(0);
    soldiers = soldiers.map((_, i) => {
        let count = 0;
        for (let j = 0; j < mat[i].length; j++) {
            if (mat[i][j] === 1) {
                count++;
            }
        }
        return [i, count];
    });

    soldiers.sort((i, j) => {
        if (i[1] > j[1]) return 1;
        if (i[1] < j[1]) return -1;
        if (i[0] > j[0]) return 1;
        if (i[0] < j[0]) return -1;
    });
    const sorted = soldiers.map(([a, b]) => a);
    return sorted.slice(0, k);
};
```
