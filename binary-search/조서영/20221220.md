## [LeetCode] 2389. Longest Subsequence With Limited Sum

[문제 확인](https://leetcode.com/problems/longest-subsequence-with-limited-sum/description/)

-   결과: Accepted, Runtime: 134ms(Beats 53.8%), Memory: 44.4MB(Beats 76.30%)

```js
const answerQueries = function (nums, queries) {
    const sortedArr = nums.sort((a, b) => a - b);
    const findSum = (target) => {
        let sum = 0;
        let count = 0;
        for (let i = 0; i < sortedArr.length; i++) {
            if (sum + sortedArr[i] <= target) {
                sum += sortedArr[i];
                count++;
            } else {
                break;
            }
        }

        return count;
    };

    return queries.map((ele) => findSum(ele));
};
```

</br>
</br>

## [LeetCode] 35. Search Insert Position

[문제 확인](https://leetcode.com/problems/search-insert-position/description/)

-   결과: Accepted, Runtime: 61ms(Beats 93.92%), Memory: 42.3MB(Beats 36.66%)

```js
const searchInsert = function (nums, target) {
    const targetIdx = nums.indexOf(target);
    if (targetIdx !== -1) return targetIdx;
    if (target < nums[0]) return 0;
    if (target > nums[nums.length - 1]) return nums.length;
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] < target && nums[i + 1] > target) {
            return i + 1;
        }
    }
};
```

<br>
<br>

## [LeetCode] 300. Longest Increasing Subsequence

[문제 확인](https://leetcode.com/problems/longest-increasing-subsequence/description/)

-   결과: Wrong Answer, 16 / 54 testcases passed

```js
const lengthOfLIS = function (nums) {
    // 제일 작은 수의 첫번째 인덱스를 찾기
    // 제일 큰 값의 마지막 인덱스를 찾기
    const minInitialIdx = nums.indexOf(Math.min(...nums));
    const max = Math.max(...nums);
    const maxLastIdx = nums.findLastIndex((ele) => ele === max);
    if (nums[minInitialIdx] === nums[maxLastIdx]) return 1;
    const slicedArr = nums.slice(minInitialIdx, maxLastIdx + 1);

    const set = new Set(slicedArr);
    const sortedSlicedArr = Array.from(set).sort((a, b) => a - b);

    const answer = [slicedArr[0]];
    let flag = 0;
    for (let i = 1; i < sortedSlicedArr.length - 1; i++) {
        const searchedIdx = slicedArr.indexOf(sortedSlicedArr[i]);
        if (searchedIdx > flag) {
            flag = searchedIdx;
            answer.push(slicedArr[searchedIdx]);
        }
    }
    answer.push(sortedSlicedArr[sortedSlicedArr.length - 1]);
    return answer;
};
```
